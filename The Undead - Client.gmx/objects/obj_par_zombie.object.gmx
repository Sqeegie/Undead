<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_parent</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>obj_par_enemy</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// Basic stats
health = 100;
name = "";
baseDamage = 10; // Don't know if this is going to be used. Haven't thought out attack and damage system yet

// AI handling
lastSeenTime = 0;
canSeeTarget = false;
isTargetLost = false;
target = "";
veiwDistance = 50; // Pixels

intrestLevel = 1; // 0 no path, 1 wander, 2 decected something, 3 move toward

useNodeTimer = true; // True = use the node timer; false = use the fixed time limit

// Time to continuing searching for the target when lost at each intrestLevel (In ms.)
intrestLevelAttentionSpan[0] = 0;
intrestLevelAttentionSpan[1] = 3000; // 3 sec
intrestLevelAttentionSpan[2] = 5000; // 5 sec
intrestLevelAttentionSpan[3] = 10000; // 10 sec

// Path
myPath = path_add();
pathLength = 0;
currentPathPoint = 0;

// Alerted variables
alertedTimer = 6; // Number of nodes to visit while alerted... Alt. "Lost Target" timer
alertedNode = noone; // Current alerted node
alertedLastNode = noone; // Last visited alert node
alertedVisitedNodeList = ds_list_create(); // This will hold a list of visited nodes when alerted/searching

// List of targets
targetList[0] = obj_player.object_index; // TODO: Fix this

// Movement
moveSpeed = 0;
turnRate = 0;
attemptUnstuckage = false;

// Collision
timeCollided = 0; // ms
defaultMaskRadius = 12; // Pixels
maskRadius = defaultMaskRadius; // Pixels
maskRadiusDecrementAmount = 0.01; // Hundredth of a pixel
collisionTimeTolerence = 3000; // ms

// Directions that this object is colliding with another object
collidingObjectDirections[0] = undefined;

// List of objects in the "squishy" collision list
collisionList[0] = obj_par_zombie;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>path_delete(myPath);
ds_list_destroy(alertedVisitedNodeList);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// Intrest level
for (var i = 0; i &lt; array_length_1d(targetList); i++) { // Cycle throuch every object in target list
    // TODO: Need to check if the object exists before checking the distance to it (Look below)
    if (distance_to_object(targetList[i]) &lt; viewDistance) { // Within view distance
        if (collision_line(self.x, self.y, targetList[i].x, targetList[i].y, obj_par_solid, false, true) = noone) { // No solid objects are in the way
            // TODO: Make the about if statment legit by fixing up the x and y getters. Also add more things to check for besides only obj_par_solid?
            lastSeenTime = current_time;
            target = targetList[i];
            canSeeTarget = true;
            // TODO: Set aggresion level
            // TODO: Implement different "states" of AI
        }
        else {
            lostTarget = true;
        }
    }
    else if (lostTarget) { // Cannot see the target
        if (useNodeTimer) { // Use waypoint nodes
            // TODO: Add node waypoint thingy
        }
        else { // Use fixed time limit
            if (current_time - lastSeenTime &lt; intrestLevelAttentionSpan[intrestLevel]) {
                // Saw target recently enough for the current aggresion level to continue the chase
            }
            else {
                // Timer ran out. Lost target
                canSeeTarget = false;
                lostTarget = false;
            }
        }

    }
}

// Collision

/* An issue with the following code is that when both objects are moving in the same direction, they may start to overlap each other. In fact, they may start to overlap each other regardless of which direction they're moving */

for (var i = 0; i &lt; array_length_1d(collisionList); i++) { // Cycle throuch all objects in "squishy" collision list
    
    // TODO: Need to check if the object exists first before checking the distance to it. What if there is more than one instance of that object?
    if (instance_exists(collisionList[i])) { 
        var instanceNumber = instance_number(collisionList[i]);
        var nearestInstance = instance_nearest(self.x, self.y, collisionList[i]);
    }
    // TODO: Tie the infomation gathered above with the stuff happening below
    if (distance_to_object(collisionList[i]) &lt; maskRadius) { // The object in question is within set collision radius - May want to only check the distance to the object of it's within a certain range
        // TODO: Get direction that the collision is happening in. This will be used so this object will stop moving in that direction and create the "collision"
        
        timeCollided = current_time; // Start the count for the amount of time collided with something
    }
}
if (current_time - timeCollided &gt; collisionTimeTolerence) { // Been colliding with an object in the "squishy" collision list for over the tolerated time
    maskRadius -= maskRadiusDecrementAmount; // Decrease the collision radius size to help unstick the colliding objects
}
else {
    maskRadius = defaultMaskRadius; // Reset the maskRadius when the objects are no longer colliding
    // TODO: Make the mask radius slowly increase instead of snapping to full size instantly
}


// Speed and direction
// TODO: Set speed and direction depending on aggresion level, zombie type, target direction (and if it can see the target), and other variables.\
// TODO: Stop the zombie from moving in a certain direction when colliding with something in said direction
// TODO: Will need to be able to use paths to make the AI actually inteligent instead of just trying to go directly toward the target
// TODO: Also stop speed and reset aggresion level if target is lost (May do this above in the intrest level code block)


// TODO: Need to check if the target is within striking distance and attack if so
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="3">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>path_delete(myPath);
ds_list_destroy(alertedVisitedNodeList);
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
